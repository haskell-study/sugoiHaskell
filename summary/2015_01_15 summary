0. イントロ
Haskellのソースは通常.hs、GHCiに関数をロードして用いる。\\
対話モードを用いれば、コンパイルせず関数の結果を直接見ることが出来る\\
shellを開いて「ghci」で対話モード、「:quit」か「:q」で終了\\
スクリプトmyfunctions.hsに関数を定義したならば、「:l myfunctions」でGHCiにロードできる。\\
.hsスクリプトを変更した場合は「:l myfunctions」か「:r」でリロード\\
ワークフローは.hs弄る→GHCiにロード→弄る→ファイルを変更\\

1. はじめのいっぽ
ホームディレクトリに「:set prompt "ghci> "」と書いた.ghciを作ると「Prelude>」が「ghci>」に

・演算子まとめ
ghci > 2+5
7
ghci > 49*100
4900
ghci > 1892-1472
420
ghci > 5/2
2.5
ghci > 7/3
2.3333333333333335//小数点以下第16位まで

ghci > 3*(1+2)
9
ghci > 3*1+2
5
//二項演算子に順序あり。()で演算順序指定も可能
負の数は必ず()つける。ないとエラー(先頭のみなくてもOK)

論理演算
論理積(&&)論理和(||)否定(not)
ghci > not (True&&False)
True
ghci > 5==5
True
ghci > 5/=5
False
5+4.0のようにしてもOK、5は整数型としても浮動小数型としてもふるまう
True+5や5+"aiueo"は数でないのでsuccエラー

1.1 関数呼び出し
*は関数、A*Bのような中置関数を呼び出している、殆どの関数は前置関数

succ A A+1を返す。Aは整数型か小数型
div A B A/Bの整数部分を返す。A,Bに小数を取るとエラー
min A B AとBのうち小さい方を返す。A,Bは整数型か小数型
max A B AとBのうち大きい方を返す。A,Bは整数型か小数型

これは二引数関数なので三要素以上では使えない。順序のついてるものなら引数に取れる
またこれらは優先度が演算子の中で最高

ghci > succ 9*10
100
ghci > succ (9*10)
91
ghci > div 92 10
9

2引数関数は関数を`(バッククオート、shift+@)で囲むと中置関数として呼び出せる
ghci > 92 `div` 10
9
ghci > 92 `mod` 10
2
Haskellでは引数に括弧はつけない。C言語ではsucc(9)のように書くが、これだとエラー

1.2 赤ちゃんの最初の関数
doubleMe x=x+x
をbaby.hsとして保存、「:l baby」でGHCiにロード
ghci > doubleMe 9
18
同じファイルにdoubleUs x y =x*2+y*2を追加すれば
ghci > doubleUs 2 3
10
ghci > doubleUs 2.0001 2.9999
10.0
関数の記述の順番は関係ない
引数は数とみなせるものなら何でもよい、出力は小数型なら必要な精度で調整して出力
関数の中で同じファイルの関数を呼び出すのもOK
100以下のときだけ2倍するような関数
doubleSmallNumber x = if x > 100
	then x
	else x*2
Haskellではelse文必須となる。
Cなどの命令型言語のプログラムはコンピュータが実行するステップの列なので
if文は何もしないということがありうるが、
Haskellプログラムは関数の集まりなのですべての関数は何らかの値を返す
よってすべてのifは対応するelseを持たなければならない
簡単に言えばHaskellのifは必ず値を返す式であって、文ではない
doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1
()に注意。ないと「else x*2+1」と判断される。
関数名に'(アポストロフィ、shift+7)もHaskellでは有効
Haskellでは関数名を大文字で始めてはいけない。理由は後述。
関数が一つも値をとらないとき、これを定義とか名前と呼ぶ
canonO'Brien ="It's a-me, Canon O'Brien!"
このとき関数と文字列は互いに交換できる。また、一度定義したら変更できない。

1.3 リスト入門
リストは一様なデータ構造、同じ型の要素のみ複数個格納できる。
GHCiで名前を定義するときはletキーワードを使う。
ghci > let numbers=[1,2,3,4]
ghci > numbers
[1,2,3,4]
ghci > let numbers=[1.5,2]
ghci > numbers
[1.5,2.0]
このように大きい方の型に揃えてくれる。
リスト連結
ghci > [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
ghci > "hello" ++ " " ++ "world"
"hello world"
Haskellでは文字列は文字のリストとして表される。"abc"は['a','b','c']と同じ
++演算子は一つ目のリストは最後まで走査するので、一つ目リストが長いと連結に時間がかかる
一方先頭にリストを連結するのは一瞬でおわる「:」演算子をcons演算子とも言う
ghci > 5.0:[1,2,3]
[5.0,1.0,2.0,3.0]
ghci > 1:[2.0,3.0]
[1.0,2.0,3.0]
:の左と右のリストの要素は同型でなければならないが、数は勝手に大きい方に揃えてくれる
++演算子はリストの連結なので、単一要素の追加の際も[1,2,3]++[4]と[]で囲む必要がある
ghci > 'A':" SMALL CAT"
"A SMALL CAT"
リストを要素にもつリストも作ることができる。[]
Haskellでは[1,2,3]は1:2:3:[](空リスト)の単なる構文糖衣だが、[]や[[]],[[],[]]は異なるもの。
ghci > [1,2,3,4,5] !! 3
4
位置指定は小数型ではエラー。リストの長さより大きくてもエラー。
!!演算子で先頭からの位置で抽出できる。左から一つ目は0番目の項。
中の要素が比較可能であれば、リストも比較することが出来る。
2つのリストの順序は最初に見つかった異なる要素の順序で決まる。
比較演算子は数の場合と同様。
ghci > [1,2,2]<=[1,2,3]
True
ghci > []<=[1.2]
True
空でないリストは常に空リストより大きいと判断される。
他には以下のリスト関数がある。
ghci > head [1,2,3]
1 //先頭要素抽出
ghci > tail [1,2,3]
[2,3] //先頭要素除く
ghci > last [1,2,3]
3 //最後の要素抽出
ghci > init [1,2,3]
[1,2] //最後の要素除く
これらの関数は引数に[]を取るとエラーとなる。これらはコンパイル時には捉えられないエラーなので注意。
ghci > length [1,2,3]
3
リストの長さを返す。引数が[]なら0。
ghci > null [1,2,3]
False
ghci > null []
True
引数のリストが空かどうか調べる。
ghci > reverse [1,2,3]
[3,2,1]
リストの要素を逆順に。
ghci > take 3 [1,2,3,4,5]
[1,2,3]
リストの先頭からn要素取り出したリストを出力する。nが非正なら空リストを返す。小数型だとエラー。
ghci > drop 3 [1,2,3,4,5]
[4,5]
リストの先頭からn要素省いたリストを返す。nが非正ならそのまま。
リストの長さ以上だと[]を返す。小数型だとエラー。
ghci > maximum [1,2,3]
3
ghci > minimum [1,2,3]
1
ghci > sum [1.0,2,3]
6.0
ghci > product [1.0,2,3]
6.0
上から最大要素、最小要素、総和、総積を返す。
ghci > 2 `elem` [1,2,3]
True
ghci > elem 4 [1,2,3]
False
リストとその要素と同型を引数に取り、後者が前者に含まれていればTrue,なければFalse
型が上記のようになってなければエラー

1.4 レンジでチン！
ghci > [1..5]
[1,2,3,4,5]
ghci > ['e'..'h']
"efgh"
ghci > [2,4..11]
[2,4,6,8,10]
ghci > [5,10..5*5+1]
[5,10,15,20,25]
ghci > 5 [5,10..]
[5,10,15,20,25]
最後の書き方を無限リストという。
レンジは文字でも使えるが、ステップは数でしか使えない。
減少列は
ghci > [4,3..1]
[4,3,2,1]
のようにしなければ空リストを返す。
Haskellは遅延評価なので無限リストをすぐには評価しない。必要なときのみ最初からn番目までを評価する。
ghci > take 5 (cycle [1,2,3])
[1,2,3,1,2]
ghci > take 5 (cycle "LOL ")
"LOL L"
ghci > take 5 (repeat [3])
[[3],[3],[3],[3],[3]]
cycleはリストを無限に繰り返す。空リストを引数に取るとエラーとなる。
repeatは単一の要素を無限に繰り返す。
ghci > replicate 3 10
[10,10,10]
replcate は単一の値からなるリストを作る。
浮動小数を要素に持つ無限リストを作るときは注意。精度にとってはおかしな挙動をする。
ghci > [0.1,0.3..1]
[0.1,0.3,0.5,0.7,0.89999999999999999,1.0999999999999999]

1.5 リスト内包表記
ghci > [x*2 | x <- [1..3]]
[2,4,6]
ghci > [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
4以上の奇数をを"a"に変え、4未満の奇数を"b"に変えたい。
ab xs = [if x >= 4 then "a" else "b" | x <- xs, odd x]
「odd x」はxは奇数、「even x」はxは偶数の意。
すると、
ghci > boomBang [1..10]
["a","a","b","b","b"]
となる。
ghci > [x+y | x <- [1,2,3], y <- [1,10,1000]]
[11,101,1001,12,102,1002,13,103,1003]
例えば
length' xs = sum [1 | _ <- xs]
と定義してもlength関数と同等の働きをする。
リストから取り出した値を利用しあにのでそれを使い捨てるために変数名アンダースコア(_)を利用する。
小文字を取り除く関数
removeNonUppercase st = [c | c <- st, c 'elem' ['A'..'Z']]
ghci > removeNonUppercase "ABCde"
"ABC"
リストに含まれるリストの中の要素のうち偶数のみ抽出したい
ghci > let xxs = [[1,3,5,2,1,4],[1,2,3,4],[1,4,7,10]]
ghci > [ [x | x <- xs, even x] | xs <- xxs ]
[[2,4],[2,4],[4,10]]

1.6 タプル
タプルはリストと違い複数の違う型の要素を格納できる。
リストと違い、タプルはサイズが固定となる。
ghci > (3,'hello')
(3,'hello')
ghci > ([1,2],[1,2,3],[3,4])
とすると、要素のサイズが異なる為エラーとなる。
ghci > fst (1,2)
1
ghci > snd (1,2)
2
これらの関数はペアの場合のみで、3-以上のn-タプルでは使えない。これらの場合は後述。
zip関数は直積集合を作る。
ghci > zip [1,2,3] ['a','b','c','d']
[(1,'a'),(2,'b'),(3,'c')]
長い方のリストの余りの要素は無視される。

2. 型を信じろ！
Haskellの強みの1つは強力な型システム
Haskellでは全ての式の型がコンパイル時に解っていて、そのことがコードを安全にしている。
Haskellではすべてのものが型を持つので、コンパイラはプログラムを見るだけで多くのことを推論できる。

2.1明示的な型宣言
式の型はGHCiで調べられる。
ghci > :t 'a'
'a' :: Char
ghci > :t True
True :: Bool
ghci > :t "HELLO!"
"HELLO!" :: [Char]
ghci > :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci > 4 == 5
4 == 5 :: Bool
「::」は「の型を持つ」の意
明示的な型の名前の頭文字は常に大文字、タプルについては各要素の型を表示
関数も型を持つので、関数を書く時、その関数に明示的な型宣言をするのは良い習慣である
removeNonUppercase :: [Char] -> [Char] 
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]
これは「一つの文字列を引数としてとり、別の文字列として返す」の意
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
引数と返り値の型は常に「->」で区切る。どれもこれで区切る理由は第五章。

2.2 一般的なHaskellの型
よく使うHaskellの型をいくつか見てみよう。
Int 整数。有界で最大(64bitマシンで2^63-1),最小値(同-2^63)がある。
Integer 整数。有界でないので大きな数を扱える。
Float 単精度浮動小数点数。32bit(符号1bit,指数8bit,仮数24bit)。
Double 倍精度浮動小数点数。64bit(符号1bit,指数11bit,仮数52bit)。
Bool 真理値型。TrueとFalseのみ値としてもつ。
Char Unicode文字を表す。'(シングルクオート,shift+7)で区切って表記する。文字列は[Char]と同じ。
() 空のタプルの型。
他にもタプルの要素(62個まで)の型の組み合わせによって数多くの型が存在する。

2.3 型変数
ghci > :t head
head :: [a] -> a
head関数はリストの先頭要素を返す。要素は数でも文字でもよい。
ここでaは小文字なので型の名前ではない。このaはどんな型でも取りうる型変数と呼ばれるもの。
他のプログラミング言語にあるジェネリクスにもちょっとだけ似ているが、
一般的な関数を簡単に書けるのではるかにパワフルである。
型変数を用いた関数は多相的関数と呼ばれる。
型変数には1文字より長い名前をつけてもよいが、通常abcd..を用いる。

2.4　型クラス 初級講座
型クラスは何らかの振る舞いを定義するインターフェイスである。
ある型クラスのインスタンスである型は、その型クラスが記述する振舞を実装する。
具体的には型クラスは関数の集合を定める。ある型クラスに属する関数をその型クラスのメソッドと呼ぶ。
ある型を型クラスのインスタンスにしようと考えたときにはそれらの関数がその型でどういう意味を成すのか定義する。
例をみてみよう
ghci > :t (==)
(==) :: (Eq a) => a -> a -> Bool
ほとんど全ての演算子は実際には関数。
関数の名前が特殊文字のみからなる場合、デフォルトでは中置関数になる。
前置関数として呼び出したいときは()で囲む必要がある。
=>より前にあるものは型クラス制約と呼ばれる。
「等値性関数は、同じ型の任意の2つの引数を取り、Boolを返す。
引数の2つの値の型はEqクラスのインスタンスでなければならない」
と読む。Eq型クラスは、等値性をテストするためののインターフェイスを提供する。
ある型の2つの値の等値性を比較することに意味があるなら、その型はEq型クラスのインスタンスにできる。
Haskellのすべての標準型(I/O型と関数を除く)はEqのインスタンス。
また型クラスはオブジェクト指向のクラスとは同じではない。
型の値の等値性や順序を簡単に比較したり、手軽に文字列として表示したりできるのは、これらの型クラスのおかげ。
例をみてみよう。
・Eq型クラス
Eqは等値性をテストできる型に使われる。Eqにインスタンスが実装すべき関数は==と/=。
これは関数の型変数にEqクラスの制約がついていたら、その関数の定義のどこかで==か/=が使われているということ。
型が関数を実装しているとは、その関数がその特定の型に対して使われた時の振舞を定義するということ。
・Ord型クラス
Ordは何らかの順序を付けられる型のための型クラス。
ghci > :t (>)
(>) :: (Ord a) => a -> a -> Bool
今まで見てきた型は関数を除いてすべてOrdのインスタンス。
Ordは大小比較関数>,<,>=,<=をサポートする。
compare関数はOrdのインスタンスの型の引数を2つ取り、Ordeingを返す。
OrderingはGT(より大きい),LT(より小さい)またはEQ(等しい)のいずれかの値を取る型。
ghci > "aiueo" `compare` "zebra"
LT
・Show型クラス
ある値はその型がShow型クラスのインスタンスになっていれば、文字列として表現できる。
ここまでの型は関数を除けばすべてShowのインスタンス。
関数としてのshowはShow型クラスのインスタンスに対して良く使う。
ghci > show True
"True"
ghci > show 3
"3"
・Read型クラス
ここまでの型は関数を除けばすべてReadのインスタンス。Showと対をなす型クラス。
関数としてのreadは文字列を受け取り、Readのインスタンスの型の値を返す。
ghci > read "8.2" + 3.8
12.0
しかし
ghci > read "4"
と打つとエラーとなる。
これはReadクラスのどれかを返すことしか分からず、具体的に何を返せばいいのかGHCiにはわからないから。実際
ghci > :t read
read :: (Read a) => String -> a
(Stringは[Char]の別名。どちらを用いても問題ない)となり、Readのインスタンスであることは解るが、
具体的にどの型なのかは判定できない。これを解決するために型注釈がある。以下のように::を用いる。
ghci > read "5" :: Int
5
コンパイラは殆ど型推論できるが、うまく推論できない場合もある。Haskellは静的型付け言語なので、
コードをコンパイルする(あるいはGHCiで評価される)前に全ての型が分っている必要がある。
・Enum型クラス
Enumのインスタンスは順番に並んだ型、つまり要素の値を列挙出来る型。
Enumのリテンはその値をレンジの中で使えること。
Enumのインスタンスの型には後者関数succと前者関数predも定義される。
Enumクラスのインスタンスとしては(),Bool,Char,Ordering,Int,Integer,Float,Doubleなどがある。
ghci > ['a' .. 'e']
"abcde"
ghci > [LT .. GT]
[LT,EQ,GT]
ghci > [3 .. 5]
[3,4,5]
ghci > succ 'B'
'C'
・Bounded型クラス
Bounded型クラスのインスタンスは上限と下限を持ち、それぞれminBound,maxBoundで調べることが出来る。
ghci > minBound :: Int
-2147483648
ghci > maxBound :: Bool
True
これらの関数は(Bounded a) => aという型を持つ。これらはいわば多相定数。
タプルの全ての構成要素がBoundedのインスタンスなら、そのタプル自身もBoundedになる。
ghci > maxBound :: (Bool, Int, Char)
(True, 2147483647, '\1114111')
・Num型クラス
Numは数の型クラス。このインスタンスは数のようにふるまう。数の型を調べてみると
ghci > :t 5
5 :: (Num t) => t
あらゆる数もまた多相定数として表現されていて、Num型クラスの任意のインスタンス
(Int, Integer, Float, Doubleなど)としてふるまうことが出来る
ghci > 20 :: Float
20.0
ghci > :t (*)
(*) :: (Num a) => a -> a -> a
この型クラス制約により(5::Int)*(6::Integer)はエラーとなる。
ある型をNumのインスタンスにするには、その型がすでにShowとEqのインスタンスになっている必要がある。
・Floating型クラス
Floating型クラスにはFloatとDoubleが含まれる。この型クラスは浮動小数点数に使う。
引数と返り値にがFloating型クラスのインスタンスであるような関数は、
その結果を浮動小数点数で表現できないと意味のある計算ができない。
例としてsin, cos, sqrtがある。
・Integral型クラス
INtegralも数の型クラス。
Numは実数を含むすべての数を含む一方、Integralは整数のみが含まれる。
この型クラスはIntとIntegerを含む。数を扱うのに便利な関数に以下のものがある。
fromIntegral :: (Num b, Integral a) => a -> b
この型シグネクチャから分かるのは、fromIntegralは何らかの整数を引数に取り、
より一般的な数を返すということ。この関数は整数と浮動小数点数を一緒に扱うとき役立つ。
例えばlength関数は以下の型宣言を持つ。
length :: [a] -> Int
そのためリストの長さを取得してそれに浮動小数点数を加える操作はエラーとなる。
これを無理やりしょりしたいときにfromIntegralを用いて
ghci > fromIntegral (length [1,2,3]) + 3.2
6.2
のようにする。
・まとめ
型クラスは抽象的なインターフェイスとして定義されているので、
1つの型は多数の型クラスのインスタンスになることが出来るし、
型クラスは多数の型をインスタンスとして持つことが出来る。
例えばChar型をインスタンスに持つ型クラスはEq, Ordなどたくさんある。
これは2つの文字は等値性比較と順序比較の両方が出来るから。
型をある型クラスのインスタンスにするために、いったｎべつのインスタンスにする必要があることがある。
例えば、Ordクラスのインスタンスになるためには先にEqクラスのインスタンスになる必要がある。
EqクラスのインスタンスであることはOrdクラスになるための必要十分条件である。
つまり。2つの対象が順序付け可能であることは、等値性判定が可能であるということ。

3. 関数の構文
この章ではHaskellの関数を書くための構文を見ていく。
値を手軽に分解する方法、大きなif/elseの連鎖を避ける方法、計算の中間データを一時的に保存/活用する方法を見ていく。

3.1 パターンマッチ
パターンマッチはある種のデータが従うべきパターンを指定し、そのパターンに従ってデータを分解するために使う。
例えば渡された数が7かどうか調べたい。

lucky :: Int -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"

luckyを呼ぶとパターンが上から下に試される。パターンに合致した場合のみ本文が実行される。
つまり、7を渡された時のみ"LU~"が返される。
パターン部分に具体値でなく小文字から始まる名前を書くと任意の値に合致するようになる。
↓のパターンは与えられた値に常に合致し、その値をパターンに使った名前で参照できるようになる。
勿論同じ関数をif/then/elseを使って実装することもできる。
階乗を再帰的に定義することも出来る。
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
再帰は重要なので第四章でもう一度見ていく。
パターンが網羅的でないとnon-exhaustive patternsエラーとなる。
最後に全てに合致するパターンを入れておくとプログラムのクラッシュを防げて安全。

・タプルのパターンマッチ
2つの2次元空間のベクトル(ペア)を受け取り、足し合わせる関数を書きたい。
パターンマッチを知らなければ
addVectors :: (Double,Double)->(Double,Double)->(Double,Double)
addVectors a b =(fst a + fst b, snd a + snd b)
パターンマッチ使うと
addVectors :: (Double,Double)->(Double,Double)->(Double,Double)
addVectors (x1,y1) (x2,y2)=(x1 + x2, y1 + y2)
こちらのほうが引数がタプルであることが明示されているのでわかりやすい。また網羅的。
また3次元空間のベクトルでfst,sndに対応する関数が欲しいとき
first :: (a,b,c) -> a
first (x, _, _) = x
second :: (a,b,c) -> b
second (_, y, _) = x
first :: (a,b,c) -> c
first (_, _, z) = z
のようにすればよい。(_は予約語なので、通常の変数としては使えない)

・リストのパターンマッチとリスト内包表記
リスト内包表記のパターンマッチでは失敗したら次の要素に進み、失敗した要素は破棄される
ghci > let xs = [(1,3),(4,3),(2,4),(5,3),(5,6),(3,1)]
ghci > [(x*100)+3 | (x,3) <- xs]
[103,403,503]
空リストや:を含むものもパターンとして使える。
x:xsというパターンはリストの先頭要素をxに束縛し、残りをxsに束縛する。
リストの要素がちょうど1つのとき、xsには空のリストが束縛される。これは再帰関数でよく使われる。
head関数をhead'として実装してみよう。
head' :: [a] -> a
head' [] = error "Can't call head on an empty list, dummy!"
head' (x:_) = x
この定義にあるように、複数変数に束縛したいときは、片方が_であっても()で囲まなければシンタックスエラー。
error関数は文字列を引数に鳥、その文字列でランタイムエラーを生成する。
基本的にはプログラムをクラッシュさせるものなのでみだりに用いてはいけない。
パターン部分の(x:[])は[x],(x:y:[])は[x,y]と同じだが、(x:y:_)は[]では書けない。
[]で書けるのは要素数が指定されているものだけ。
パターン部分では++演算子をつかうことができない。

・asパターン
asパターンは、値をパターンに分解しつつ、パターンマッチの対象になった値自体も参照したいときに使う。
asパターンを作るには普通のパターン前に名前と@を追加する。
例えば
firstLetter :: String -> String
firstLetter "" = "Empty string, whoops!"
firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
ghci > firstLetter "apple"
"The first letter of apple is a"

3.2 場合分けして、きっちりガード！
パターンマッチでは引数の構造で場合分けした。
引数の値が満たす性質で場合分けしたいときはガードを用いる。
複数の条件があるときはif文よりガードのほうが可読性が高く、パターンマッチとの相性もよい。
BMIによって叱り方を変えるプログラム
bmiTell :: Double -> Double -> String
bmiTell weight height
    |weight / height^2 <= 18.5 = "a"
    |weight / height^2 <= 25.0 = "b"
    |weight / height^2 <= 30.0 = "c"
    |otherwise   = "d"
がーどにはパイプ文字(|)とそれに続く真理値式、さらに関数の本文が続く。
上から読むのはパターンマッチと同じ。
大抵の場合最後のガードはotherwiseになっている。
全てFalseに評価されてotherwiseも無かった場合、次のパターンに移る。適切なパターンがなければエラー。
`(バッククオート、shift+@)による中置記法は関数呼び出しだけでなく関数定義でも使える。

3.3 where?!
bmiTell weight height
    |bmi <= 18.5 = "a"
    |weight / height^2 <= 25.0 = "b"
    |weight / height^2 <= 30.0 = "c"
    |otherwise   = "d"
    where bmi = weight / height^2
のように定義を書き換えることができる。whereキーワードを使うと、この値を一回だけしか計算しなくて済む。
whereの後の変数や関数は複数でもよいが、インデントがずれているとエラーとなる。
whereの中で定義した変数はその関数内でしか使えないが、グローバルに使いたいときは外に出す必要がある。
whereの束縛の中でもパターンマッチを使うことができる。

3.4 let it be
let式の中でもパターンマッチを使うことが出来る。
cylinder :: Double -> Double -> Double
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^ 2
    in  sideArea + 2 * topArea
let式は式なので値を持つが、where節は式でないので値を持たないという違いがある。
例えば
ghci > 4*(let a = 9 in a + 1) + 2
42
というようにも文中のどこでも使える。以下に便利な用法を書く。
ローカルスコープに関数を作れる。
ghci > [let square x = x * x in (square 5, square 3, suare 2)]
[(25,9,4)]
セミコロンで区切れる。
ghci > (let a = 100; b = 200; c = 300 in a*b*c,
        let foo="Hey "; bar = "there!" in foo ++ bar)
(600000,"Hey there!")
let式とパターンマッチでタプルを要素に分解して名前に束縛できる。
ghci > (let (a, b, c) = (1, 2, 3) in a+b+c) * 100
600
let式はリスト内包表記の中ｄえも使える。詳しくは後述。
let式は局所的なので、関数全体をスコープに取る変数を定義したければwhereの方が適当

・リスト内包表記でのlet
例えば体重と新著のペアのリストを計算する関数をwhereとletで書くと

calcBmis :: [(Double, Double)] -> [Double]
calcBmis xs = [bmi w h | (w, h) <- xs]
    where bmi weight height = weight / height ^ 2

calcBmis :: [(Double, double)] -> [Double]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]

(w, h) <- xsの部分はジェネレータと呼ばれる。letよりも前に定義されているので、変数bmiはジェネレータから参照不可。

・GHCiでのlet
GHCiで直接関数や定数を定義するときはinを省略できる。このときこの定義はセッション全体から参照できる。
ghci > let zoot x y z = x * y + z
ghci > zoot 3 4 2
14
inを省略しなかった場合は参照できない。

3.5 case式
case式は変数の指定した値に対するコードブロックを評価できる。
ようするにどこでもパターンマッチできる。
head' :: [a] -> a
head' xs = case xs of [] -> error "No head for empty lines!"
                      (x:_) -> x
はhead関数と同じ働きをする。
引数によるパターンマッチが使えるのは関数を定義するときだけだが、case式はどこでも使える。例えば
describeList :: [a] -> String
describeList ls = "The list is "
                  ++ case ls of [] -> "empty."
                                [x] -> "a singleton list."
                                xs -> "a longer list." 

これをwhereを使って書くと
describeList :: [a] -> String
describeList ls = "The list is " ++ what ls
    where what [] = "empty."
          what [x] = "a singleton list."
          what xs = "a longer list."
となる。

P.50まで。
