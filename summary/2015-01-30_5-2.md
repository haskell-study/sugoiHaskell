### 5.3 関数プログラマの道具箱  
いくつかの便利な関数を紹介していく。  
・map関数  
map関数は関数とリストを受け取り、その関数をリストの全ての要素に適用して新しいリストを返す。  
```
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = fx : map f xs
```
```
ghci > map (map (^2)) [[1,2],[3,4]]
[[1,4],[9,16]]
```
原理的にはリスト内包表記を使っても同じことができる。(教科書p.69参照)  
・filter関数  
filter関数は述語とリストを受け取り、そのリストの要素のうち述語がTrueなもののみからなるリストを返す。  
```
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
  | p x = x : filter p xs
  | otherwise = filter p xs
```
```
ghci > ('elem' ['a'..'z']) "kDFSiDCtCDayCEUuXCJtUNa iNDIsU BteBDIKnsNKaJi"
"kitayutaistensai"
```
これもmap関数と同様リスト内包表記と述語を使って書ける。文脈に応じて適切な方を選択すると良い。  
述語が複数にわたる場合は、filter関数を複数回適用するか、述語を論理関数`&&`でつないで指定する。  
4章のquicksortk関数もfilterを使って書き直すと可読性が高い。各自やってみよう。  
・takewhile関数  
```
takeWhile :: (a -> Bool) -> [a] -> [a]
```
takeWhile関数は述語とリストを受け取り、リストの先頭から初めて述語の条件が満たされる限りリストの要素を返し続ける。  
条件に合わない要素が見つかったらリストを返すのをやめる。  
```
ghci > takeWhile (/=3) [0,1,2,3,4,5,6,7,8,9]
[0,1,2]
```
以上の関数を組み合わせるとこのようなこともできる。  
10000より小さい全ての奇数の平方数の和を求めたい。
```
ghci > sum (takeWhile (< 10000) (filter odd (map (^2) [1..])))
166650
```
・コラッツ予想  
```
chain :: Integer -> [Integer]
chain 1 = [1]
chain n
  | even n = n:chain (n `div` 2)
  | odd n = n:chain (n * 3 + 1)
```
任意の自然数は偶数の時は2で割り、奇数の時は3を掛けて1を足す操作を続けるといずれ1に収束するという予想がある。  
```
ghci > chain 100
[100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1]
```
このコラッツ列の長さが15より大きいものは1~100の間にいくつあるだろうか？  
```
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
  where isLong xs = length xs > 15
```
```
ghci > numLongChains
66
```
・map関数に複数の引数を与える  
map関数に2つの引数を取らせることもできる。  
```
ghci > let listOfFunctions = map (*) [0..]
ghci > (listOfFunctions !! 4) 5
20
```
ここでlistOdFunctionsは自然数と何かを書ける関数のリストであり、その4番目の要素は(4*)と等価である。  
つまり何か(引数)に5を取ると4*5=20となる。  
### 5.4 ラムダ式  
ラムダ式とは一回だけ必要な関数を作るときに使う無名関数。通常は高階関数に渡す関数を作るためだけに使われる。  
ラムダ式を宣言するにはバックスラッシュ(\)を書いて、それから関数の引数をスペース区切りで書く。  
続けて->、最後に関数の本体を書く。また全体は()で囲むことが多い。前節の  
```
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
  where isLong xs = length xs > 15
```
は
```
numLongChains :: Int
numLongChains = length (filter (\xs -> length xs > 15)) (map chain [1..100])
```
とラムダ式を用いて全く同義に書き換えられる。  
また普通の関数と同じようにラムダ式も任意の数の引数を取ることが出来る。  
```
ghci > zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
[33.0,16.5,11.0,8.25,6.6]
```
パターンマッチもできるが、複数のパターンを定義することはできない。(パターンマッチに失敗するとランタイムエラー)  
```
ghci > map (\(a,b) -> a + b) [(1,2),(3,5),(6,3)]
[3,8,9]
```
### 5.5 畳み込み、見込みアリ！
畳み込み関数を使うと、データ構造を単一の値に纏めることが出来る。  
畳み込み関数は2引数関数と畳み込みに用いる値(アキュムレータと呼ばれることが多い)の初期値、それと畳み込むリストを受け取る。  
```
foldl :: (a -> b -> a) -> a -> [b] -> a -- 左畳み込み
foldr :: (a -> b -> b) -> b -> [a] -> b -- 右畳み込み
```
この左畳み込みを用いてsum関数を定義しなおすと
```
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0 xs
```
```
ghci > sum' [1,2,3]
6
```
ここでは0(初期値、自分で定義した)+1+2+3=6という畳み込みを行っている。  
  
畳み込みのアキュムレータの値、結果の値は任意の型で構わない。数でも真理値でもリストでもよい。  
map関数を右畳み込みで実装してみよう。  
```
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
```
注意 リストは右から走査することはできない。foldr関数はあくまでリストを左から走査するけど、  
結果だけ見ると右から折りたたんだように見えるということ。  
