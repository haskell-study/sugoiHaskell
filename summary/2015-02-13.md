# 第7章 型や型クラスを自分で作ろう
これまで色々なデータ型が紹介されてきたが、この章では独自のデータ型・および型クラスを定義し、活用することを考える。

## 7.1 新しいデータ型を定義する
自作のデータ型を作る方法の一つは`data`キーワードを使うことである。
```haskell
data Bool = False | True
```
等号の前は型名を、等号の後は値コンストラクタを指す。値コンストラクタは、型の取りうる値の種類を指定している。型名と値コンストラクタとの区別は重要である。なお、型名・値コンストラクタは、両者ともに大文字で始まる必要がある。

## 7.2 形づくる
値コンストラクタはフィールドを持つことができる。
```haskell
data Shape = Circle Float Float Float | Rectangle Float Float Float Float
```
値コンストラクタは、実際はそのデータ型の値を返す関数である。一方で、パターンマッチに使うこともできる。

自作のデータ型も自作のモジュールからエクスポートできる。型をエクスポートするには、関数と同様に行えばよいが、値コンストラクタをエクスポートするには、型名の後に括弧を追加し、その中にカンマ区切りで値コンストラクタを書く。値コンストラクタをすべてエクスポートするには、ピリオド2つ(..)を書く。
値コンストラクタをエクスポートしないでモジュール内に隠蔽し、モジュールの提供する補助関数のみを使ってデータ型にアクセスさせることにより、データ型の実装を隠してデータ型の抽象度を上げることができる。ただし、値コンストラクタをそのままエクスポートすることも必ずしも悪くはない。

## 7.3 レコード構文
これまでの記法の場合、フィールドの数が増えてくると煩雑になる場合が多くなる。そこで、レコード構文が用意されている。
```haskell
data Person = Person {firstName :: String, lastName :: String, age :: Int}
```
レコード構文を使用した場合、フィールドを取得する関数も自動的に作成される。

## 7.4 型引数
値コンストラクタが（あれば）引数を取って新しい値を生成するのと同様、型コンストラクタは型を引数に取って新しい型を作る、型レベルのメタな関数と捉えることもできる。
```haskell
data Maybe a = Nothing | Just a
```
ほとんどの場合、型推論のおかげで明示的に型を引数に渡したりする必要はないが、明示的な型注釈を行なうこともできる。
型引数は、さまざまな型を扱う汎用コンテナを作成できるので便利である。

データ宣言に型クラス制約を加える事は推奨されない（現在のGHCでは無効化されている）。

## 7.5 インスタンスの自動導出
型宣言の直後に`deriving (Eq, Show)`などと書くことでHaskellは自動的に特定の型クラスのインスタンス宣言を導出してくれる。`Eq`, `Ord`, `Enum`, `Bounded`, `Show`, `Read` がその対象となる。

## 7.6 型シノニム
型シノニムを使うことで、型に別の名前をつけることができる。
```haskell
type String = [Char]
```
ただし、新しい型が作られているわけではない。また、たとえ型名と値コンストラクタの名前が同一であったとしても、値コンストラクタの別名まで作成されるわけではない。
型シノニムも型引数を取るようにすることができる。
```haskell
type AssocList k v = [(k,v)]

型引数を取るデータ型として、`Either`はエラー処理などでよく使用される。`Maybe`に比べて、エラー時に詳細な情報を返すことができるという利点がある。
