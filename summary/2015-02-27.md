# 第11章 ファンクターからアプリカティブファンクターへ
さまざまな型クラスのうち、ファンクターおよびアプリカティブファンクタ−について取り上げる。ファンクターは関数を使って写すことのできる「文脈を持った」値であり、アプリカティブファンクターはそれより少し強力、すなわち、「文脈を持った」関数を使って写すことのできる「文脈を持った」値である、という風にイメージされる。

## 11.1 帰ってきたファンクター
型コンストラクタを`Functor`のインスタンスにするには、その型コンストラクタの kind は`* -> *`でなければならない。よって、`instance Functor Either where`、`instance Functor (Either a b) where`というインスタンス宣言は誤りであり、`instance Functor (Either a) where`が正しい。

I/O アクションはファンクターとして働く。`fmap`を使うことで、一度`let`で束縛する必要があった処理を、`let`なしで記述する事が可能となる。

関数はファンクターとして働く。なお、関数の型を表す`r -> a`は、`(->) r a`と書き換えられることに注意する。関数の場合、`fmap`は関数合成、すなわち`(.)`に他ならない。

```haskell
fmap :: (Functor f) => (a -> b) -> f a -> f b
```
この型宣言からは、`fmap`は関数とファンクター値を取ってファンクター値を返す2引数関数と捉えられるが、これと等価な
```haskell
fmap :: (Functor f) => (a -> b) -> (f a -> f b)
```
という型宣言を見ると、関数(`a -> b`)を取って、ファンクター値を取りファンクター値を返す関数(`f a -> f b`)を返す操作、すなわち持ち上げ(lifting)だとも捉えられる。これらの見方は当然どちらも正しい。

## 11.2 ファンクター則
```haskell
fmap id = id
fmap (f . g) = fmap f . fmap g
```
これらの2つの法則は、ファンクターが関数の素直な拡張であり、`fmap`を使った時に関数で中身の値が写される以外の余計なことが行われないことを保証する。すべてのファンクターはこれらのファンクター則を満たすように実装するべきである。

## 11.3 アプリカティブファンクターを使おう
アプリカティブファンクターは、アプリカティブファンクター中の関数にアプリカティブファンクター中の値を適用してアプリカティブファンクターで包まれた値を返すことができる。アプリカティブファンクターのクラス定義は以下の通り。
```haskell
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
```
`pure`は、値を取って最小の文脈に包んで返す。`<*>`は、上述のような拡張された関数適用である。

アプリカティブファンクターなら、複数のアプリカティブファンクターを組み合わせて使うことができる。これはファンクターと大きく異なる点である。

アプリカティブ則の一つとして、`pure f <*> x`は`fmap f x`と等しい。このことを使って、例えば`pure f <*> x <*> y <*> ...`を`fmap f x <*> y <*> ...`と書き換えられる。このパターンは多用されるので、`fmap`と等価な演算子`<$>`が用意されている。これを用いれば、さらに`f <$> x <*> y <*> ...`と書き換えられる。

IO、関数、リストなどはアプリカティブである。特に、リストにはアプリカティブにする方法が複数存在する。

アプリカティブ則をすべて挙げると、
```haskell
pure f <*> x = fmap f x
pure id <*> v = v
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
pure f <*> pure x = pure (f x)
u <*> pure y = pure ($ y) <*> u
```
以上である。

## 11.4 アプリカティブの便利な関数
アプリカティブはファンクターとは異なり、複数のアプリカティブを一度に扱えるのが強みである。例えば、
```haskell
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
sequenceA :: (Applicative f) => [f a] -> f [a]
```
などといった関数が作れる。`liftA2`は`fmap`と同じようなことを2引数関数について行なう関数であり、`sequenceA`はアプリカティブのリストをリストのアプリカティブに変換する関数である。なお、I/Oに対する`sequenceA`は、`sequence`に他ならない。