#2. 型を信じろ！
Haskellの強みの1つは強力な型システム
Haskellでは全ての式の型がコンパイル時に解っていて、そのことがコードを安全にしている。
Haskellではすべてのものが型を持つので、コンパイラはプログラムを見るだけで多くのことを推論できる。

##2.1明示的な型宣言
式の型はGHCiで調べられる。
ghci > :t 'a'
'a' :: Char
ghci > :t True
True :: Bool
ghci > :t "HELLO!"
"HELLO!" :: [Char]
ghci > :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci > 4 == 5
4 == 5 :: Bool
「::」は「の型を持つ」の意
明示的な型の名前の頭文字は常に大文字、タプルについては各要素の型を表示
関数も型を持つので、関数を書く時、その関数に明示的な型宣言をするのは良い習慣である
removeNonUppercase :: [Char] -> [Char] 
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]
これは「一つの文字列を引数としてとり、別の文字列として返す」の意
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
引数と返り値の型は常に「->」で区切る。どれもこれで区切る理由は第五章。

##2.2 一般的なHaskellの型
よく使うHaskellの型をいくつか見てみよう。
Int 整数。有界で最大(64bitマシンで2^63-1),最小値(同-2^63)がある。
Integer 整数。有界でないので大きな数を扱える。
Float 単精度浮動小数点数。32bit(符号1bit,指数8bit,仮数24bit)。
Double 倍精度浮動小数点数。64bit(符号1bit,指数11bit,仮数52bit)。
Bool 真理値型。TrueとFalseのみ値としてもつ。
Char Unicode文字を表す。'(シングルクオート,shift+7)で区切って表記する。文字列は[Char]と同じ。
() 空のタプルの型。
他にもタプルの要素(62個まで)の型の組み合わせによって数多くの型が存在する。

##2.3 型変数
ghci > :t head
head :: [a] -> a
head関数はリストの先頭要素を返す。要素は数でも文字でもよい。
ここでaは小文字なので型の名前ではない。このaはどんな型でも取りうる型変数と呼ばれるもの。
他のプログラミング言語にあるジェネリクスにもちょっとだけ似ているが、
一般的な関数を簡単に書けるのではるかにパワフルである。
型変数を用いた関数は多相的関数と呼ばれる。
型変数には1文字より長い名前をつけてもよいが、通常abcd..を用いる。

##2.4　型クラス 初級講座
型クラスは何らかの振る舞いを定義するインターフェイスである。
ある型クラスのインスタンスである型は、その型クラスが記述する振舞を実装する。
具体的には型クラスは関数の集合を定める。ある型クラスに属する関数をその型クラスのメソッドと呼ぶ。
ある型を型クラスのインスタンスにしようと考えたときにはそれらの関数がその型でどういう意味を成すのか定義する。
例をみてみよう
ghci > :t (==)
(==) :: (Eq a) => a -> a -> Bool
ほとんど全ての演算子は実際には関数。
関数の名前が特殊文字のみからなる場合、デフォルトでは中置関数になる。
前置関数として呼び出したいときは()で囲む必要がある。
=>より前にあるものは型クラス制約と呼ばれる。
「等値性関数は、同じ型の任意の2つの引数を取り、Boolを返す。
引数の2つの値の型はEqクラスのインスタンスでなければならない」
と読む。Eq型クラスは、等値性をテストするためののインターフェイスを提供する。
ある型の2つの値の等値性を比較することに意味があるなら、その型はEq型クラスのインスタンスにできる。
Haskellのすべての標準型(I/O型と関数を除く)はEqのインスタンス。
また型クラスはオブジェクト指向のクラスとは同じではない。
型の値の等値性や順序を簡単に比較したり、手軽に文字列として表示したりできるのは、これらの型クラスのおかげ。
例をみてみよう。
###・Eq型クラス
Eqは等値性をテストできる型に使われる。Eqにインスタンスが実装すべき関数は==と/=。
これは関数の型変数にEqクラスの制約がついていたら、その関数の定義のどこかで==か/=が使われているということ。
型が関数を実装しているとは、その関数がその特定の型に対して使われた時の振舞を定義するということ。
###・Ord型クラス
Ordは何らかの順序を付けられる型のための型クラス。
ghci > :t (>)
(>) :: (Ord a) => a -> a -> Bool
今まで見てきた型は関数を除いてすべてOrdのインスタンス。
Ordは大小比較関数>,<,>=,<=をサポートする。
compare関数はOrdのインスタンスの型の引数を2つ取り、Ordeingを返す。
OrderingはGT(より大きい),LT(より小さい)またはEQ(等しい)のいずれかの値を取る型。
ghci > "aiueo" `compare` "zebra"
LT
###・Show型クラス
ある値はその型がShow型クラスのインスタンスになっていれば、文字列として表現できる。
ここまでの型は関数を除けばすべてShowのインスタンス。
関数としてのshowはShow型クラスのインスタンスに対して良く使う。
ghci > show True
"True"
ghci > show 3
"3"
###・Read型クラス
ここまでの型は関数を除けばすべてReadのインスタンス。Showと対をなす型クラス。
関数としてのreadは文字列を受け取り、Readのインスタンスの型の値を返す。
ghci > read "8.2" + 3.8
12.0
しかし
ghci > read "4"
と打つとエラーとなる。
これはReadクラスのどれかを返すことしか分からず、具体的に何を返せばいいのかGHCiにはわからないから。実際
ghci > :t read
read :: (Read a) => String -> a
(Stringは[Char]の別名。どちらを用いても問題ない)となり、Readのインスタンスであることは解るが、
具体的にどの型なのかは判定できない。これを解決するために型注釈がある。以下のように::を用いる。
ghci > read "5" :: Int
5
コンパイラは殆ど型推論できるが、うまく推論できない場合もある。Haskellは静的型付け言語なので、
コードをコンパイルする(あるいはGHCiで評価される)前に全ての型が分っている必要がある。
###・Enum型クラス
Enumのインスタンスは順番に並んだ型、つまり要素の値を列挙出来る型。
Enumのリテンはその値をレンジの中で使えること。
Enumのインスタンスの型には後者関数succと前者関数predも定義される。
Enumクラスのインスタンスとしては(),Bool,Char,Ordering,Int,Integer,Float,Doubleなどがある。
ghci > ['a' .. 'e']
"abcde"
ghci > [LT .. GT]
[LT,EQ,GT]
ghci > [3 .. 5]
[3,4,5]
ghci > succ 'B'
'C'
###・Bounded型クラス
Bounded型クラスのインスタンスは上限と下限を持ち、それぞれminBound,maxBoundで調べることが出来る。
ghci > minBound :: Int
-2147483648
ghci > maxBound :: Bool
True
これらの関数は(Bounded a) => aという型を持つ。これらはいわば多相定数。
タプルの全ての構成要素がBoundedのインスタンスなら、そのタプル自身もBoundedになる。
ghci > maxBound :: (Bool, Int, Char)
(True, 2147483647, '\1114111')
###・Num型クラス
Numは数の型クラス。このインスタンスは数のようにふるまう。数の型を調べてみると
ghci > :t 5
5 :: (Num t) => t
あらゆる数もまた多相定数として表現されていて、Num型クラスの任意のインスタンス
(Int, Integer, Float, Doubleなど)としてふるまうことが出来る
ghci > 20 :: Float
20.0
ghci > :t (*)
(*) :: (Num a) => a -> a -> a
この型クラス制約により(5::Int)*(6::Integer)はエラーとなる。
ある型をNumのインスタンスにするには、その型がすでにShowとEqのインスタンスになっている必要がある。
###・Floating型クラス
Floating型クラスにはFloatとDoubleが含まれる。この型クラスは浮動小数点数に使う。
引数と返り値にがFloating型クラスのインスタンスであるような関数は、
その結果を浮動小数点数で表現できないと意味のある計算ができない。
例としてsin, cos, sqrtがある。
###・Integral型クラス
INtegralも数の型クラス。
Numは実数を含むすべての数を含む一方、Integralは整数のみが含まれる。
この型クラスはIntとIntegerを含む。数を扱うのに便利な関数に以下のものがある。
fromIntegral :: (Num b, Integral a) => a -> b
この型シグネクチャから分かるのは、fromIntegralは何らかの整数を引数に取り、
より一般的な数を返すということ。この関数は整数と浮動小数点数を一緒に扱うとき役立つ。
例えばlength関数は以下の型宣言を持つ。
length :: [a] -> Int
そのためリストの長さを取得してそれに浮動小数点数を加える操作はエラーとなる。
これを無理やりしょりしたいときにfromIntegralを用いて
ghci > fromIntegral (length [1,2,3]) + 3.2
6.2
のようにする。
###・まとめ
型クラスは抽象的なインターフェイスとして定義されているので、
1つの型は多数の型クラスのインスタンスになることが出来るし、
型クラスは多数の型をインスタンスとして持つことが出来る。
例えばChar型をインスタンスに持つ型クラスはEq, Ordなどたくさんある。
これは2つの文字は等値性比較と順序比較の両方が出来るから。
型をある型クラスのインスタンスにするために、いったｎべつのインスタンスにする必要があることがある。
例えば、Ordクラスのインスタンスになるためには先にEqクラスのインスタンスになる必要がある。
EqクラスのインスタンスであることはOrdクラスになるための必要十分条件である。
つまり。2つの対象が順序付け可能であることは、等値性判定が可能であるということ。
