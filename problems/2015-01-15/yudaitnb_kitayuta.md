## 解答
### 1-1
(1) エラーとなる。`div 4 div`が計算されようとしてしまうため。`div 4 (div 6 2) -1` とすればよい。

(2) エラーとなる。``-4 `div` 2``は整数型であるが、`succ 1.0`は浮動小数点型であり、型の違う値同士はそのままでは足し算することはできない。例えば、``-4 `div` 2 + succ 1``とするか、``fromIntegral (-4 `div` 2) + succ 1.0``とすればよい。ただし、前者は整数型であるが、後者は浮動小数点型となる。

### 1-2
`div`,`mod` と `quot`,`rem` は、引数がどちらも非負の値の場合には同じ結果を返す。
```
Prelude> divMod 7 3
(2,1)
Prelude> quotRem 7 3
(2,1)
```
しかし、どちらか片方だけが負であった場合には違う結果を返す。
```
Prelude> divMod (-7) 3
(-3,2)
Prelude> quotRem (-7) 3
(-2,-1)
Prelude> divMod 7 (-3)
(-3,-2)
Prelude> quotRem 7 (-3)
(-2,1)
```
`quot`は割って0に近くなるように切り捨て、`rem`はその`quot`と整合するようになっている。これは、Cなどの`/`,`%`の動作と同じである。一方、`mod`は除数と剰余の符号が等しくなるように定義されており、`div`はその`mod`と整合するようになっている。(ただし、除数が負の場合に`div`,`mod`を考えることはあまりないであろうが……) このような仕様の違いのため、上述の違った結果が生まれる。
ちなみに、この仕様に従うと、引数が両方とも負である場合は結果が同じになる。
```
Prelude> divMod (-7) (-3)
(2,-1)
Prelude> quotRem (-7) (-3)
(2,-1)
```

### 1-3
(1) `10`
(2) `5`
(3) `False`
(4) `True`

### 1-4
```
Prelude> let tris = [(a,b,c) | c<-[50,49..1],b<-[1..c],a<-[1..b],c^2==a^2+b^2]
Prelude> length tris
20
Prelude> tris
[(30,40,50),(14,48,50),(27,36,45),(9,40,41),(24,32,40),(15,36,39),(12,35,37),(21,28,35),(16,30,34),(18,24,30),(20,21,29),(10,24,26),(15,20,25),(7,24,25),(12,16,20),(8,15,17),(9,12,15),(5,12,13),(6,8,10),(3,4,5)]
```

### 2-1
(1) `(>) :: (Ord a) => a -> a -> Bool`

(2) `compare :: (Ord a) => a -> Ordering`

(3) `(/=) :: (Eq a) => a -> a -> Bool`

(4) `"True"`

### 2-2
(1) 型推論に必要な情報が不足しているため。型注釈を行えばよい。`read "1" ::  Int`などとする。

(2) 第一項は整数型なのに対し、第二項は浮動小数点型であるため。`fromIntegral (length [1,2,3]) + 3.2`とすればよい。

### 2-3
* Eq : 等値性が定義される型のクラス。
* Ord : 順序が定義される型のクラス。
* Show : Stringに変換できる型のクラス。
* Read : Stringから変換できる型のクラス。
* Enum : 列挙が可能な型のクラス。レンジで使用できる型のクラスとも言える。
* Bounded : 有界な型のクラス。上限と下限が定義される。
* Num : 数全体の型のクラス。
* Floating : 浮動小数点型全体のクラス。
* Integral : 整数型全体のクラス。

### 3-1
(1)
```haskell
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

fib' n
    | n == 0 = 0
    | n == 1 = 1
    | otherwise = fib' (n-1) + fib' (n-2)

fib'' n = case n of 0 -> 0
                    1 -> 1
                    _ -> fib'' (n-1) + fib'' (n-2)
```
(2)
```haskell
fibo = 0 : 1 : zipWith (+) fibo (drop 1 fibo)
```

### 3-2
(1)

コード
```haskell
farey 1 = [(0,1),(1,1)]
farey n = add $ farey (n-1)
    where add (it@((a,b)):tl@((c,d):_))
              | b+d == n = it : (a+c,b+d) : add tl
              | otherwise = it : (add tl)
          add last = last
```

出力
```
*Main> farey 6
[(0,1),(1,6),(1,5),(1,4),(1,3),(2,5),(1,2),(3,5),(2,3),(3,4),(4,5),(5,6),(1,1)]
```

(2)

コード
```haskell
farey2 0 = [(0,1),(1,1)]
farey2 n = add $ farey2 (n-1)
    where add (it@((a,b)):tl@((c,d):_)) = it : (a+c,b+d) : add tl
          add last = last

stern n = [fst x | x <- farey2 n]
```

出力
```
*Main> stern 4
[0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1]
*Main> stern 5
[0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1]
```
`stern 5` のはじめの項が `stern 4` と完全に一致していることが確認できる。

(3)

コード((2)からの続き)
```haskell
stern' m = (stern 100) !! m
set1 n = [(stern' a, stern' (2*a))  | a <- [1..n] ]
set2 n = [(stern' (2*a+1), stern' a + stern' (a+1)) | a <- [1..n]]
```

出力
```
*Main> set1 100
[(1,1),(1,1),(2,2),(1,1),(3,3),(2,2),(3,3),(1,1),(4,4),(3,3),(5,5),(2,2),(5,5),(3,3),(4,4),(1,1),(5,5),(4,4),(7,7),(3,3),(8,8),(5,5),(7,7),(2,2),(7,7),(5,5),(8,8),(3,3),(7,7),(4,4),(5,5),(1,1),(6,6),(5,5),(9,9),(4,4),(11,11),(7,7),(10,10),(3,3),(11,11),(8,8),(13,13),(5,5),(12,12),(7,7),(9,9),(2,2),(9,9),(7,7),(12,12),(5,5),(13,13),(8,8),(11,11),(3,3),(10,10),(7,7),(11,11),(4,4),(9,9),(5,5),(6,6),(1,1),(7,7),(6,6),(11,11),(5,5),(14,14),(9,9),(13,13),(4,4),(15,15),(11,11),(18,18),(7,7),(17,17),(10,10),(13,13),(3,3),(14,14),(11,11),(19,19),(8,8),(21,21),(13,13),(18,18),(5,5),(17,17),(12,12),(19,19),(7,7),(16,16),(9,9),(11,11),(2,2),(11,11),(9,9),(16,16),(7,7)]
*Main> set2 100
[(2,2),(3,3),(3,3),(4,4),(5,5),(5,5),(4,4),(5,5),(7,7),(8,8),(7,7),(7,7),(8,8),(7,7),(5,5),(6,6),(9,9),(11,11),(10,10),(11,11),(13,13),(12,12),(9,9),(9,9),(12,12),(13,13),(11,11),(10,10),(11,11),(9,9),(6,6),(7,7),(11,11),(14,14),(13,13),(15,15),(18,18),(17,17),(13,13),(14,14),(19,19),(21,21),(18,18),(17,17),(19,19),(16,16),(11,11),(11,11),(16,16),(19,19),(17,17),(18,18),(21,21),(19,19),(14,14),(13,13),(17,17),(18,18),(15,15),(13,13),(14,14),(11,11),(7,7),(8,8),(13,13),(17,17),(16,16),(19,19),(23,23),(22,22),(17,17),(19,19),(26,26),(29,29),(25,25),(24,24),(27,27),(23,23),(16,16),(17,17),(25,25),(30,30),(27,27),(29,29),(34,34),(31,31),(23,23),(22,22),(29,29),(31,31),(26,26),(23,23),(25,25),(20,20),(13,13),(13,13),(20,20),(25,25),(23,23),(26,26)]
```

`set1 100`, `set2 100` はタプルの二要素が全て一致していることが確認できる。
