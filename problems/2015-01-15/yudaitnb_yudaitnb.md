## 2015/01/15 yudaitnb問題模範解答
  
### 1-1
答えが0になることを想定して以下の式を立てた。  
正しいときは出力を、エラーとなるときは理由を説明し適切な形に直せ。  
(1)``ghci > div 4 div 6 2 -1``  
(2)``ghci > -4 `div` 2 + succ 1.0``  
  
### 1-1(答え)  
(1)エラー。`(div 4 div) 6 2 - 1`と判断される為。  
`ghci > div 4 (div 6 2) - 1`  
とすればよい。詳しくは第五章。  
(2)エラー。関数+の二引数は同型である必要がある。従って1.0を整数型にするか、``-4 `div` 2``を浮動小数型にすればよい。  
`(+) :: Num a => a -> a -> a`  
````
ghci > -4 `div` 2 + succ 1
0
ghci > fromIntegral (-4 `div` 2) + succ 1.0
0.0
````
  
### 1-2(PC)  
この章では関数divやmodを学習した。  
ところで商と余りを求める関数には、これらの他にquotやremがある。  
````
quot :: Integral a => a -> a -> a
rem  :: Integral a => a -> a -> a
````
これらの関数は共に  
(quot x y) * y + (rem x y) == x  
(div  x y) * y + (mod x y) == x  
(「==は(x,yについて)恒等的に等しい」の意。)  
を満たすのだが、明確な違いがある。説明せよ。  
  
また、調べる際に関数quotRemやdivModを用いることで商と余りを同時に出力できる。  
便利なのでこれらを使って調べてみよう。  
````
quotRem :: Integral a => a -> a -> (a, a)  
divMod  :: Integral a => a -> a -> (a, a)
````
  
### 1-2(答え)  
負の整数も引数に取れることに注意。x,yが共に正のときや、xがyで割り切れる際には違いは無い。  
割り切れない時に0の方に切り捨てるのがquotで、無限大の方に切り捨てるのがdiv。  
(quotは0から出発して割られる数の手前まで引き、残りを余りで処理する。  
divは0から出発して割られる数を追い越し、超えてしまった分を余りで処理すると覚えればよい。)  
  
例  
割り切れるとき  
````
ghci > quotRem (-6) 3
(-2,0)
ghci > divMod (-6) 3
(-2,0)
````
割り切れないとき  
````
ghci > quotRem (-7) 3
(-2,-1)
````
-7 = -2 * 3 - 1
````
ghci > divMod (-7) 3
(-3,2)
````
-7 = -3 * 3 + 2
````
ghci > quotRem 7 (-3)
(-2,1)
````
-7 = -2 * -3 + 1
````
ghci > divMod 7 (-3)
(-3,-2)
````
7 = -3 * -3 - 2
  
### 1-3  
以下の出力を答えよ。なお、全ての出力はエラーではない。  
````
ghci > let a = [[1,2],[2,3],[3,4]]  
ghci > let b = init (tail ([0,1] : (a ++ [[4,5]])))  
````
``ghci > sum (b !! 2) + length b``  
(1)  
``ghci > sum (maximum (2 `take` b))``  
(2)  
``ghci > [0,1] `elem` b || null b``  
(3)  
``ghci > null (drop 5 b) && [0,2] < minimum b``  
(4)  
  
### 1-3(答え)  
(1)`10`  
(2)`5`  
(3)`False`  
(4)`True`  
  
### 1-4(PC)  
各辺の長さが50以下の正整数である直角三角形はいくつあるか。  
また、条件を満たす直角三角形の各辺の長さa,b,c(a<b<c)としたとき、cが大きい順に出力せよ。  
(cが等しいタプルの順番は適当でよい。)  
  
### 1-4(答え)  
教科書p.21~22に同様の問題があるので参照されたし。ただし、教科書とは出力の順番が異なる。  
cについて降順に出力しなければならないので、cの束縛元を逆順のリストにすればよい。  
```
ghci > let triangles = [(a,b,c)|c<-[50,49..1],b<-[1..50],a<-[1..50],a^2+b^2==c^2]
ghci > length triangles
20
```

````
ghci > triangles
[(30,40,50),(14,48,50),(27,36,45),(9,40,41),(24,32,40),(15,36,39),(12,35,37),(21,28,35),(16,30,34),(18,24,30),(20,21,29),(10,24,26),(15,20,25),(7,24,25),(12,16,20),(8,15,17),(9,12,15),(5,12,13),(6,8,10),(3,4,5)]
````
  
### 2-1  
以下の出力を書け。  
``ghci > :t (>)``  
(1)  
``ghci > :t compare``  
(2)  
``ghci > :t (/=)``  
(3)  
``ghci > (show True)``  
(4)  
  
### 2-1(答え)  
(1)`(>) :: Ord a => a -> a -> Bool`  
(2)`compare :: Ord a => a -> a -> Ordering`  
(3)`(/=) :: Eq a => a -> a -> Bool`  
(4)`"True"`  
  
### 2-2  
以下の式の出力はエラーが出る。理由を説明し、期待される出力となる適切な形に直せ。  
(1)  
``ghci > read "1"``  
1  
(2)  
``ghci > length[1,2,3] + 3.2``  
6.2  

### 2-2(答え)  
(1)1がReadクラスのインスタンスであるどの型になるのか判断不能な為。型注釈すれば解決。  
````
ghci > read "1" :: Int
1
````  
(2)関数`+`の2引数の型が異なる。`fromIntegral (length[1,2,3])`などとすればよい。
````
ghci > fromIntegral (length[1,2,3]) + 3.2
6.2
````
  
### 2-3  
まとめ(どのようなクラスかパッと説明できると良い。)  
Eq型クラス  
Ord型クラス  
Show型クラス  
Read型クラス  
Enum型クラス  
Bounded型クラス  
Num型クラス  
Floating型クラス  
Integral型クラス  
  
### 2-3(答え)  
* Eq : 等値性が定義される型のクラス。
* Ord : 順序が定義される型のクラス。
* Show : Stringに変換できる型のクラス。
* Read : Stringから変換できる型のクラス。
* Enum : 列挙が可能な型のクラス。レンジで使用できる型のクラスとも言える。
* Bounded : 有界な型のクラス。上限と下限が定義される。
* Num : 数全体の型のクラス。
* Floating : 浮動小数点型全体のクラス。
* Integral : 整数型全体のクラス。
  
### 3-1(PC)  
(1)  
フィボナッチ数列をパターンマッチ、ガード、case-ofのそれぞれを用いて記述せよ。  
(2)  
zipWithという関数がある。A,Bをリストとして    
``zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]``    
zipWith 関数(演算子など) A B    
でA,Bの要素をそれぞれ先頭から順に引数とし、関数を適用して    
できた要素を、新しいリストに加える。また、A,Bの片方が空リストの場合はそこでストップする。    
この関数を用いて再帰的に無限リストfiboを定義し、take関数を用いて第20項までを要素に持つリストを出力せよ。    
例    
````
ghci > zipWith (*) [1,2,3] [2,3,4]
[2,6,12]    
````
  
### 3-1(答え)  
(1)  
パターンマッチ
````
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
````
ガード
````
fib' :: Int -> Int
fib' n
    | n == 0 = 0
    | n == 1 = 1
    | otherwise = fib' (n-1) + fib' (n-2)
````
case-of
````
fib'' :: Int -> Int
fib'' n = case n of
    0 -> 0
    1 -> 1
    _ -> fib'' (n-1) + fib'' (n-2)
````
(2)
````
fibo :: Num a => [a]
fibo = 0:1:zipWith (+) fib (tail fib)
````
````
ghci > take 20 fibo
[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
````
  
### 3-2(PC)  
ある自然数nに対して、[0,1]にある既約分数で分母がn以下のものを小さい順に並べたものをfarey数列(farey n)とよぶ。  
この問題では分数をタプルとして表示する。つまり、farey 1は0/1,1/1とし、この時`faray 1 = [(0,1),(1,1)]`と定義する。 
  
(1)一般に、n < mのfarey nについて、隣接する分数の分子、分母同士をそれぞれ足し合わせ、  
割って出来る分数の分母がmのとき、farey m - 1にこれら全てを加えるとfarey mになることが知られている。  
これを「操作」と呼ぼう。  
 ````
 farey 1 = [(0,1),(1,1)]  
 farey 2 = [(0,1),(1,2),(1,1)]  
 farey 3 = [(0,1),(1,3),(1,2),(2,3),(1,1)]  
 farey 4 = [(0,1),(1,4),(1,3),(1,2),(2,3),(3,4),(1,1)]  
 ....  
 ````
操作をうまく利用して、farey nをリストとして出力せよ。  
  
(2)今度は、「操作」をあるリストに含まれる全ての隣接する分数の分子、分母同士をそれぞれ足し合わせ、  
割ってできる分数をそのリストに加えるものとする。  
`farey2 0 = [(0,1),(1,1)]`に対してn回操作を加えた数列(昇順)をfarey2 nとする。  
このとき、farey2 nの分子のみをfarey2 nと同じ順番で並べた数列をstern nと名付ける。  
````
farey2 1 = [(0,1),(1,2),(1,1)]  
farey2 2 = [(0,1),(1,3),(1,2),(2,3),(1,1)]  
farey2 3 = [(0,1),(1,4),(1,3),(2,5),(1,2),(3,5),(2,3),(3,4),(1,1)]  
....  
````
````
stern 0 = [0,1]  
stern 1 = [0,1,1]
stern 2 = [0,1,1,2,1]  
stern 3 = [0,1,1,2,1,3,2,3,1]
....  
````
このとき、stern nの最初のいくつかの項がstern (n-1)と完全に一致することを確認せよ。  
  
(3)こんどは
``stern' m = (stern 100) !! m``
とする。   
````
set1 n = [(stern' a, stern' (2*a))  | a <- [1..n] ]
set2 n = [(stern' (2*a+1), stern' a + stern' (a+1)) | a <- [1..n]]
````
として、set1 100, set2 100を出力せよ。  
このとき、出力されたリストに含まれた各タプルには同じ数字が含まれているはずである。  

### 3-2(答え)  
Farey数列を題材とした。定義は以下の通り。  
「自然数 n に対して、n に対応する（または、属する）ファレイ数列 (Farey sequence of order n) Fn とは、  
分母が n 以下で、 0 以上 1 以下の全ての既約分数を小さい順から並べてできる有限数列である。  
(ただし、整数 0, 1 はそれぞれ分数0/1,1/1として扱う。)」  
(1)  
````
farey :: Int -> [(Int, Int)]
farey n = farey' [(0, 1), (1, 1)]
    where
      farey' ((a, b) : xs@((c, d) : _))
          | b + d > n = (a, b) : farey' xs
          | otherwise = farey' ((a, b) : (a + c, b + d) : xs)
      farey' xs = xs
````
````
ghci > farey 5
[(0,1),(1,5),(1,4),(1,3),(2,5),(1,2),(3,5),(2,3),(3,4),(4,5),(1,1)]
ghci > farey 6
[(0,1),(1,6),(1,5),(1,4),(1,3),(2,5),(1,2),(3,5),(2,3),(3,4),(4,5),(5,6),(1,1)]
````
分母の最大値が6になるまで操作を施したFarey数列が出力されていることがわかる。  
(2)  
逆にこの操作に注目してこの数列を整理してみることを考える。こうしてできた数列farey2の分子のみを取り出した数列を  
スターン二原子数列(stern's diatomic sequence)という。この数列は中々面白い数列で、  
近年フラクタルとの関連も指摘されているらしい。(2),(3)ではこの数列の特徴について確認する。  
````
farey2 :: (Num t1, Num t, Num a, Eq a) => a -> [(t, t1)]
farey2 0 = [(0,1),(1,1)]
farey2 n = far' (far (n-1))
    where
        far' ((a,b) : xs@((c,d) : _)) = (a,b) : (a + c, b + d) : far' xs
        far' xs = xs

stern n = [fst x | x <- farey2 n]
````
````
ghci > stern 4
[0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1]
ghci > stern 5
[0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1]
ghci > stern 6
[0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11,7,10,3,11,8,13,5,12,7,9,2,9,7,12,5,13,8,11,3,10,7,11,4,9,5,6,1]
````

(3)  
````
stern' :: Num a => Int -> a
stern' n = [fst x | x <- farey2 100] !! n
  
set1 :: (Num t1, Num t) => Int -> [(t, t1)]
set1 n = [(stern' a, stern' (2*a))  | a <- [1..n] ]
set2 :: (Num t1, Num t) => Int -> [(t, t1)]
set2 n = [(stern' (2*a+1), stern' a + stern' (a+1)) | a <- [1..n]]
````
````
ghci > set1 100
[(1,1),(1,1),(2,2),(1,1),(3,3),(2,2),(3,3),(1,1),(4,4),(3,3),(5,5),
(2,2),(5,5),(3,3),(4,4),(1,1),(5,5),(4,4),(7,7),(3,3),(8,8),(5,5),
(7,7),(2,2),(7,7),(5,5),(8,8),(3,3),(7,7),(4,4),(5,5),(1,1),(6,6),
(5,5),(9,9),(4,4),(11,11),(7,7),(10,10),(3,3),(11,11),(8,8),(13,13),
(5,5),(12,12),(7,7),(9,9),(2,2),(9,9),(7,7),(12,12),(5,5),(13,13),
(8,8),(11,11),(3,3),(10,10),(7,7),(11,11),(4,4),(9,9),(5,5),(6,6),
(1,1),(7,7),(6,6),(11,11),(5,5),(14,14),(9,9),(13,13),(4,4),(15,15),
(11,11),(18,18),(7,7),(17,17),(10,10),(13,13),(3,3),(14,14),(11,11),
(19,19),(8,8),(21,21),(13,13),(18,18),(5,5),(17,17),(12,12),(19,19),
(7,7),(16,16),(9,9),(11,11),(2,2),(11,11),(9,9),(16,16),(7,7)]
  
ghci > set2 100
[(2,2),(3,3),(3,3),(4,4),(5,5),(5,5),(4,4),(5,5),(7,7),(8,8),(7,7),
(7,7),(8,8),(7,7),(5,5),(6,6),(9,9),(11,11),(10,10),(11,11),(13,13),
(12,12),(9,9),(9,9),(12,12),(13,13),(11,11),(10,10),(11,11),(9,9),
(6,6),(7,7),(11,11),(14,14),(13,13),(15,15),(18,18),(17,17),(13,13),
(14,14),(19,19),(21,21),(18,18),(17,17),(19,19),(16,16),(11,11),
(11,11),(16,16),(19,19),(17,17),(18,18),(21,21),(19,19),(14,14),
(13,13),(17,17),(18,18),(15,15),(13,13),(14,14),(11,11),(7,7),(8,8),
(13,13),(17,17),(16,16),(19,19),(23,23),(22,22),(17,17),(19,19),
(26,26),(29,29),(25,25),(24,24),(27,27),(23,23),(16,16),(17,17),
(25,25),(30,30),(27,27),(29,29),(34,34),(31,31),(23,23),(22,22),
(29,29),(31,31),(26,26),(23,23),(25,25),(20,20),(13,13),(13,13),
(20,20),(25,25),(23,23),(26,26)]
````
