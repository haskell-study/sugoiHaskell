## 2015/01/23 yudaitnb問題模範解答  
Pascalの三角形を題材にした。  
魔方陣が成立するかどうかは各格子点の魔力に依るので、まず魔力を求めよう。各格子点を図示すれば下図のようになる。  
この図ではスタート地点からの距離をn,この図で最左経路からk番目の部屋をp(n,k)と名付けている。  
但し、初期位置はp(0,0),最左辺上にある格子点はk=0,最右辺上にある格子点はk=nとする。  
```
n\k|00000|00001|00002|00003|00004|00005
0|||p(0,0)  
1|||p(1,0)p(1,1)  
2|||p(2,0)p(2,1)p(2,2)  
3|||p(3,0)p(3,1)p(3,2)p(3,3)  
4|||p(4,0)p(4,1)p(4,2)p(4,3)p(4,4)  
5|||p(5,0)p(5,1)p(5,2)p(5,3)p(5,4)p(5,5)  
....
```
この図で任意のp(n,k)はp(n-1,k-1),p(n-1,k+0),p(n+0,k-1),p(n+0,k+1),p(n+1,k+0),p(n+1,k+1)の周囲6点(端に近いとこれより少ない)と道で繋がっている。  
最短距離を通りp(n,k)まで行く場合の数は二項係数nCkであるから、この迷路の各格子点の魔力はpascalの三角形の各数字と一致する。  
魔力を先ほどと同様に図示してみると  
```
n\k|000|001|002|003|004|005|  
0|||001|  
1|||001|001|  
2|||001|002|001|  
3|||001|003|003|001|  
4|||001|004|006|004|001|  
5|||001|005|010|010|005|001|  
....  
```
これで魔力が解った。一般にnCkを出力したいので、二項係数の基本的な公式  
```
(n-1)C(k-1) + (n-1)Ck = nCk  
```
を用いて素朴に書くと  
````haskell
conb :: Integer -> Integer -> Integer
conb n k
	| k == 0 = 1
	| k == n = 1
	| otherwise = ue1 + ue2
	where
		ue1 = conb (n-1) (k-1)
		ue2 = conb (n-1) k
````
となる。パスカルの三角形を出力したければ  
```haskell
pascalTri n = map (conb n) [0..n]  
-- (conb n)のところでカリー化された関数を用いている。  
ghci> sequence $ map print (map pascalTri [0..10])
[1]
[1,1]
[1,2,1]
[1,3,3,1]
[1,4,6,4,1]
[1,5,10,10,5,1]
[1,6,15,20,15,6,1]
[1,7,21,35,35,21,7,1]
[1,8,28,56,70,56,28,8,1]
[1,9,36,84,126,126,84,36,9,1]
[1,10,45,120,210,252,210,120,45,10,1]
[(),(),(),(),(),(),(),(),(),(),()]
```
とすればよい。  
これを用いて迷路のn<=mの範囲で魔方陣となりうる6角形を探す。
````haskell
hexa :: Int -> [[(Int, Int)]]
hexa m
	| m <= 2 = []
	| m > 2 = [ [(a,s),(a,t),((b-u+s),s),((a-t+v),v),(b,u),(b,v)] | 
		a <- [1..(m-2)], b <- [(a+2)..m], s <- [0..(a-1)], t <- [(s+1)..a], 
		u <- [(s+1)..(s+b-a-1)], v <- [(u+1)..(t+b-a-1)],
		(b-u+s) > a, (b-u+s) < b, (a-t+v) > a, (a-t+v) < b,
		(conb a s)*(conb b u)*(conb (a-t+v) v)
		==(conb a t)*(conb (b-u+s) s)*(conb b v) ]
````
図を書いてみればm<=2では条件を満たす6角形は存在しないことは容易にわかる。(そもそも六角形の入るスペースが無い)  
このコードにおいてaは六角形上辺のn、bは六角形下辺のn、sは六角形上辺左点のk、tは六角形上辺右点のk、  
uは六角形下辺左点のk、vは六角形下辺右点のkである。  
六角形の辺の長さが1以上であることや、b-aは2以上であることを用いて探索範囲を狭めていることに注意してほしい。  
これで  
````
ghci> sequence $ map print (hexa 5)
[(1,0),(1,1),(2,0),(2,2),(3,1),(3,2)]
[(1,0),(1,1),(3,0),(3,3),(4,1),(4,3)]
[(1,0),(1,1),(4,0),(4,4),(5,1),(5,4)]
[(1,0),(1,1),(3,0),(3,3),(5,2),(5,3)]
[(2,0),(2,1),(3,0),(3,2),(4,1),(4,2)]
[(2,0),(2,2),(3,0),(3,3),(4,1),(4,3)]
[(2,1),(2,2),(3,1),(3,3),(4,2),(4,3)]
[(2,0),(2,1),(4,0),(4,3),(5,1),(5,3)]
[(2,0),(2,2),(4,0),(4,4),(5,1),(5,4)]
[(2,0),(2,2),(3,0),(3,3),(5,2),(5,3)]
[(2,1),(2,2),(4,1),(4,4),(5,2),(5,4)]
[(3,0),(3,1),(4,0),(4,2),(5,1),(5,2)]
[(3,0),(3,3),(4,0),(4,4),(5,1),(5,4)]
[(3,1),(3,2),(4,1),(4,3),(5,2),(5,3)]
[(3,2),(3,3),(4,2),(4,4),(5,3),(5,4)]
[(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
````
となり、数字を変えれば各mについて条件を満たす全ての頂点の組み合わせが出力される。  
しかし、この記述では計算量過剰の為、せいぜいhexa 15程度までしか出力できない。そこで魔力を求める式を工夫しよう。  
第一回のyudaitnb問題3-1(2)で用いたテクニックを使えば少ない計算量でPascalの三角形を無限リストとして得られる。  
ここから二項係数を取り出せば二項係数の計算が劇的に高速化できそうだ。  
```
pascal :: [[Integer]]
pascal = [1]:[ zipWith (+) ([0]++xs) (xs++[0]) | xs <- pascal ]  
con :: Int -> Int -> Integer
con n k = (pascal !! n) !! k
```
又は
```haskell
pascal' :: [[Integer]]
pascal' = [1] : [[1] ++ zipWith (+) xs (tail xs) ++ [1] | xs <- pascal']
con' :: Int -> Int -> Integer
con' n k = (pascal !! n) !! k
```  
とし、関数hexaを  
````
hexagon :: Int -> [[(Int, Int)]]
hexagon m
	| m <= 2 = []
	| m > 2 = [ [(a,s),(a,t),((b-u+s),s),((a-t+v),v),(b,u),(b,v)] | 
		a <- [1..(m-2)], b <- [(a+2)..m], s <- [0..(a-1)], t <- [(s+1)..a], 
		u <- [(s+1)..(s+b-a-1)], v <- [(u+1)..(t+b-a-1)],
		(b-u+s) > a, (b-u+s) < b, (a-t+v) > a, (a-t+v) < b,
		(con a s)*(con b u)*(con (a-t+v) v)
		== (con a t)*(con (b-u+s) s)*(con b v) ]
lhexagon :: Int -> Int
lhexagon m = length (hexagon m)
````
と書き換えてやるとm=30であっても20秒程度で成立する魔方陣の個数を出力できる。
参考までに
```
m
01 0
02 0
03 1
04 5
05 15

06 34

07 68

08 124

09 204

10 314

11 473

12 679

13 955

14 1208

15 1720

16 2242

17 2886

18 3642

19 4561

20 5601

21 6825

22 8212

23 9852

24 11680

25 13804

26 16162

27 18847

28 21811

29 25149

30 28800

```


### 余談1  

nが少ないPascalの三角形を眺めてると、成立する魔方陣は全て何かしらの対称性を持つ綺麗な六角形であるような気がしてくる。左右対称だったり、回転対称だったり。  

ただし、これはn<=10までの話である。nが10を超えると全く対称性の無い魔方陣が出現するのだ。  

この汚い魔方陣を見てみよう。  

```

notTaisyo :: Int -> [[(Int, Int)]]

notTaisyo m

	| m <= 2 = []

	| m > 2 = [ [(a,s),(a,t),((b-u+s),s),((a-t+v),v),(b,u),(b,v)] | 

		a <- [1..(m-2)], b <- [(a+2)..m], s <- [0..(a-1)], t <- [(s+1)..a], 

		u <- [(s+1)..(b-a+s-1)], v <- [(u+1)..(b-a+t-1)],

		(b-u+s) > a, (b-u+s) < b, (a-t+v) > a, (a-t+v) < b,

		(con a s)*(con b u)*(con (a-t+v) v)

		== (con a t)*(con (b-u+s) s)*(con b v), 
		(b-u+s) /= (a-t+v) ]--上辺と下辺でない2点の高さが異なる

```

```
ghci> sequence $ map print (notTaisyo 11)

[(2,0),(2,1),(6,0),(4,3),(8,2),(8,3)]

[(2,0),(2,1),(6,0),(5,4),(8,2),(8,4)]

[(2,1),(2,2),(5,1),(6,6),(8,4),(8,6)]

[(2,1),(2,2),(4,1),(6,6),(8,5),(8,6)]

[(6,0),(6,3),(9,0),(10,7),(11,2),(11,7)]

[(6,0),(6,4),(9,0),(10,8),(11,2),(11,8)]

[(6,2),(6,6),(10,2),(9,9),(11,3),(11,9)]

[(6,3),(6,6),(10,3),(9,9),(11,4),(11,9)]

[(),(),(),(),(),(),(),()]

```

このうち上の4つは図示してみると回転対称形になっている。  

下の4つは、各辺の長さが上辺から左回りに(3,3,2,5,1,4)や(4,3,2,6,1,4)であり、何の対称性もない汚い形であることが見てとれる。
  
  
### 余談2  
上で用いた関数hexagonでもまだ無駄があるので、この実装を高速化することを考えてみよう。  
まず  
```
		(b-u+s) > a, (b-u+s) < b, (a-t+v) > a, (a-t+v) < b,

```
の4式のうち``(a-t+v) > a``以外はこのa,b,s,t,u,vの束縛だと恒真式。同値変形して`v > t`とできる。  
さらに、各点の探索をb=mで分けて処理し、関数全体を再帰的に定義しなおすと  
```
lh :: Num a => Int -> a
lh m
	| m <= 2 = 0
	| m > 2 = lh (m-1) + sum [ 1 | 
		a <- [1..(m-2)], s <- [0..(a-1)], t <- [(s+1)..a], 
		u <- [(s+1)..(s+m-a-1)], v <- [(u+1)..(t+m-a-1)], v > t,
		(con a s)*(con m u)*(con (a-t+v) v)
		== (con a t)*(con (m-u+s) s)*(con m v) ]
```
とできる。このlhはm=30であっても12秒ほどで結果を出力することが出来る。
