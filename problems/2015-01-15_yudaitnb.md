### (PC)とついている問題のみPC使用可
  
### 1-1
答えが0になることを想定して以下の式を立てた。  
正しいときは出力を、エラーとなるときは理由を説明し適切な形に直せ。  
(1)``ghci > div 4 div 6 2 -1``  
(2)``ghci > -4 `div` 2 + succ 1.0``  
  
### 1-2(PC)  
この章では関数divやmodを学習した。  
ところで商と余りを求める関数には、これらの他にquotやremがある。  
````
quot :: Integral a => a -> a -> a
rem  :: Integral a => a -> a -> a
````
これらの関数は共に  
````
(quot x y) * y + (rem x y) == x  
(div  x y) * y + (mod x y) == x
````
「==は(x,yについて)恒等的に等しい」の意。 
を満たすのだが、明確な違いがある。説明せよ。  
  
また、調べる際に関数quotRemやdivModを用いることで商と余りを同時に出力できる。  
便利なのでこれらを使って調べてみよう。  
````
quotRem :: Integral a => a -> a -> (a, a)  
divMod  :: Integral a => a -> a -> (a, a)
````
  
### 1-3  
以下の出力を答えよ。なお、全ての出力はエラーではない。  
````
ghci > let a = [[1,2],[2,3],[3,4]]  
ghci > let b = init(tail([0,1] : (a ++ [[4,5]])))  
````
``ghci > sum(b !! 2) + length b``  

(1)  
``ghci > sum(maximum(2 `take` b))``  
(2)  
``ghci > [0,1] `elem` b || null b``  
(3)  
``ghci > null(drop 5 b) && [0,2] < minimum b``   
(4)  
  
### 1-4(PC)  
各辺の長さが50以下の正整数である直角三角形はいくつあるか。  
また、条件を満たす直角三角形の各辺の長さa,b,c(a<b<c)としたとき、cが大きい順に出力せよ。  
(cが等しいタプルの順番は適当でよい。)  
  
### 2-1  
以下の出力を書け。  
``ghci > :t (>)``  
(1)  
``ghci > :t compare``  
(2)  
``ghci > :t (/=)``  
(3)  
``ghci > (show True)``  
(4)  
  
### 2-2  
以下の式の出力はエラーが出る。理由を説明し、期待される出力となる適切な形に直せ。  
(1)  
``ghci > read "1"``  
1  
(2)  
``ghci > length[1,2,3] + 3.2``  
6.2  
  
### 2-3  
まとめ(どのようなクラスかパッと説明できると良い。)  
Eq型クラス  
Ord型クラス  
Show型クラス  
Read型クラス  
Enum型クラス  
Bounded型クラス  
Num型クラス  
Floating型クラス  
Integral型クラス  
  
### 3-1(PC)  
(1)  
フィボナッチ数列をパターンマッチ、ガード、case-ofのそれぞれを用いて記述せよ。  
(2)  
zipWithという関数がある。A,Bをリストとして    
``zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]``    
zipWith 関数(演算子など) A B    
でA,Bの要素をそれぞれ先頭から順に引数とし、関数を適用して    
できた要素を、新しいリストに加える。また、A,Bの片方が空リストの場合はそこでストップする。    
この関数を用いて再帰的に無限リストfiboを定義し、take関数を用いて第20項までを要素に持つリストを出力せよ。    
例    
````
ghci > zipWith (*) [1,2,3] [2,3,4]
[2,6,12]    
````
  
### 3-2(PC)  
ある自然数nに対して、[0,1]にある既約分数で分母がn以下のものを小さい順に並べたものをfarey数列(farey n)とよぶ。  
この問題では分数をタプルとして表示する。つまり、farey 1は0/1,1/1とし、この時faray 1 = [(0,1),(1,1)]と定義する。 
  
(1)一般に、n < mのfarey nについて、隣接する分数の分子、分母同士をそれぞれ足し合わせ、  
割って出来る分数の分母がmのとき、farey m - 1にこれら全てを加えるとfarey mになることが知られている。  
これを「操作」と呼ぼう。  
 ````
 farey 1 = [(0,1),(1,1)]  
 farey 2 = [(0,1),(1,2),(1,1)]  
 farey 3 = [(0,1),(1,3),(1,2),(2,3),(1,1)]  
 farey 4 = [(0,1),(1,4),(1,3),(1,2),(2,3),(3,4),(1,1)]  
 ....  
 ````
操作をうまく利用して、farey nをリストとして出力せよ。  
  
(2)今度は、`farey2 0 = [(0,1),(1,1)]`(0項目がこの数列！)に対してn回操作を加えた数列(昇順)をfarey2 nとする。  
このとき、farey2 nの分子のみをfarey2 nと同じ順番で並べた数列をstern nと名付ける。  
````
farey2 1 = [(0,1),(1,2),(1,1)]  
farey2 2 = [(0,1),(1,3),(1,2),(2,3),(1,1)]  
farey2 3 = [(0,1),(1,4),(1,3),(2,5),(1,2),(3,5),(2,3),(3,4),(1,1)]  
....  
````
````
stern 0 = [0,1]  
stern 1 = [0,1,1]
stern 2 = [0,1,1,2,1]  
stern 3 = [0,1,1,2,1,3,2,3,1]
....  
````
このとき、stern nの最初のいくつかの項がstern (n-1)と完全に一致することを確認せよ。  
  
(3)こんどは  
````
set1 n = [(stern a, stern (2*a))  | a <- [1..n] ]
set2 n = [(stern (2*a+1), stern a + stern (a+1)) | a <- [1..n]]
````
として、set1 100, set2 100を出力せよ。  
このとき、出力されたリストに含まれた各タプルには同じ数字が含まれているはずである。  
