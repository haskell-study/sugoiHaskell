## 1-1
#### (1)
エラー。二つ目のdivが一つ目のdivの引数として評価されてしまっているため。
```sh
ghci > div 4 (div 6 2) -1
```
#### (2)
エラー。``-4 `div` 2``が返す値の型と、`succ 1.0`の返す値の型が異なっているため。具体的には整数と浮動小数点数を足そうとしているが、それはできないため。
```sh
ghci > -4 `div` 2 + succ 1
```

## 1-2
`a * b < 0`において
```math
|(div a b) * b| >= |a|
|(quat a b) * b| <= |a|
```
の違いがある。

## 1-3
#### (1)
```sh
10
```
※僕の環境で確かめたらエラーが出た。
#### (2)
```sh
5
```
#### (3)
```sh
False
```
#### (4)
```sh
True
```

## 1-4
個数は
```sh
ghci> sum [ 1 | c <- [50,49 .. 1], b <- [1 .. c], c <- [1 .. b], a*a + b*b == c*c]
20
```
より得る。
また、三角形のリストは
```sh
ghcighci> [ (a,b,c) | c <- [50,49 .. 1], b <- [1 .. c], c <- [1 .. b], a*a + b*b == c*c] 
[(30,40,50),(14,48,50),(27,36,45),(9,40,41),(24,32,40),(15,36,39),(12,35,37),(21,28,35),(16,30,34),(18,24,30),(20,21,29),(10,24,26),(15,20,25),(7,24,25),(12,16,20),(8,15,17),(9,12,15),(5,12,13),(6,8,10),(3,4,5)]
```
とすることで、cの大きい順に出力することができる。

## 2-1
#### (1)
```sh
(>) :: Ord a => a -> a -> Bool
```
#### (2)
```sh
compare :: Ord a => a -> a -> Ordering
```
#### (3)
```sh
(/=) :: Eq a => a -> a -> Bool
```
#### (4)
```sh
"True"
```

## 2-2
#### (1)
`1は多相定数でありこのままでは型が定まらない。
```haskell
read "1" :: Int
```
のように型注釈を用いればよい。
#### (2)
1-1 (2)と同じ理由でエラーとなる。整数をより一般的な数にする`fromIntegral`関数を用い
て、
```haskell
fromIntegral (length [1,2,3]) + 3.2
```
とすればよい。(p.32)

## 2-3
Eq: 等値性を評価できる  
Ord: 順序付けられる
Show: 文字列として表現できる
Read: 文字列から特定の型に戻せる
Enum: 順序が定義されている
Bounded: 上限と下限がある
Num: 数
Floating: 浮動小数点数
Integral: 整数

## 3-1
#### (1)
##### パターンマッチ
```haskell
fibp 0 = 0
fibp 1 = 1
fibp n = fibo (n-1) + fibo (n-2)
```
##### ガード
```haskell
fibg n
  | n == 0    = 0
  | n == 1    = 1
  | otherwise = fibo (n-1) + fibo (n-2)
```
##### case-of
```haskell
fibc n = case n of  0 -> 0
                    1 -> 1
                    n -> fibc (n-1) + fibc (n-2)
```
#### (2)
```haskell
fibo = 0:1:zipWith (+) (fibo) (tail fibo) 
```

## 3-2
#### (1)
```haskell
farey 1 = [(0,1), (1,1)]
farey n = [(a,b) | (a,b) <- (0,1):sousa (farey (n-1)), b <= n]
  where sousa ((a, b):(c, d):[]) = [(a+c, b+d), (c, d)]
        sousa (a:b:xs) = sousa [a,b] ++ sousa (b:xs)  
```
#### (2)
```haskell
farey2 1 = [(0,1), (1,1)]
farey2 n = (0,1):sousa (farey2 (n-1))
  where sousa ((a, b):(c, d):[]) = [(a+c, b+d), (c, d)]
        sousa (a:b:xs) = sousa [a,b] ++ sousa (b:xs)  
```
(1)の内包的表記をなくしただけ
#### (3)
```sh
ghci> set1 100
[(1,1),(1,1),(2,2),(1,1),(3,3),(2,2),(3,3),(1,1),(4,4),(3,3),(5,5),(2,2),(5,5),(3,3),(4,4),(1,1),(5,5),(4,4),(7,7),(3,3),(8,8),(5,5),(7,7),(2,2),(7,7),(5,5),(8,8),(3,3),(7,7),(4,4),(5,5),(1,1),(6,6),(5,5),(9,9),(4,4),(11,11),(7,7),(10,10),(3,3),(11,11),(8,8),(13,13),(5,5),(12,12),(7,7),(9,9),(2,2),(9,9),(7,7),(12,12),(5,5),(13,13),(8,8),(11,11),(3,3),(10,10),(7,7),(11,11),(4,4),(9,9),(5,5),(6,6),(1,1),(7,7),(6,6),(11,11),(5,5),(14,14),(9,9),(13,13),(4,4),(15,15),(11,11),(18,18),(7,7),(17,17),(10,10),(13,13),(3,3),(14,14),(11,11),(19,19),(8,8),(21,21),(13,13),(18,18),(5,5),(17,17),(12,12),(19,19),(7,7),(16,16),(9,9),(11,11),(2,2),(11,11),(9,9),(16,16),(7,7)]
ghci> set2 100
[(2,2),(3,3),(3,3),(4,4),(5,5),(5,5),(4,4),(5,5),(7,7),(8,8),(7,7),(7,7),(8,8),(7,7),(5,5),(6,6),(9,9),(11,11),(10,10),(11,11),(13,13),(12,12),(9,9),(9,9),(12,12),(13,13),(11,11),(10,10),(11,11),(9,9),(6,6),(7,7),(11,11),(14,14),(13,13),(15,15),(18,18),(17,17),(13,13),(14,14),(19,19),(21,21),(18,18),(17,17),(19,19),(16,16),(11,11),(11,11),(16,16),(19,19),(17,17),(18,18),(21,21),(19,19),(14,14),(13,13),(17,17),(18,18),(15,15),(13,13),(14,14),(11,11),(7,7),(8,8),(13,13),(17,17),(16,16),(19,19),(23,23),(22,22),(17,17),(19,19),(26,26),(29,29),(25,25),(24,24),(27,27),(23,23),(16,16),(17,17),(25,25),(30,30),(27,27),(29,29),(34,34),(31,31),(23,23),(22,22),(29,29),(31,31),(26,26),(23,23),(25,25),(20,20),(13,13),(13,13),(20,20),(25,25),(23,23),(26,26)]
ghci> 
```
